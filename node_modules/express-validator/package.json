{
  "_from": "express-validator",
  "_id": "express-validator@5.1.2",
  "_inBundle": false,
  "_integrity": "sha512-dzPMpwBk/nGbF6Tj9HssTB+4q2mWl/w8ydEyBxJwAwIQAbcF0QqXEloCg5XFxtKcrMCzMw/6k/7fEbOiSo0SSw==",
  "_location": "/express-validator",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "express-validator",
    "fetchSpec": "latest",
    "name": "express-validator",
    "raw": "express-validator",
    "rawSpec": "",
    "registry": true,
    "saveSpec": null,
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/express-validator/-/express-validator-5.1.2.tgz",
  "_shasum": "1eecf5f583f8eeaf879563c38a2b3ac996eba1df",
  "_spec": "express-validator",
  "_where": "C:\\Users\\John Wiand\\Documents\\GitHub\\COSC412Project",
  "author": {
    "email": "dev@tavan.de",
    "name": "Christoph Tavan"
  },
  "bugs": {
    "url": "https://github.com/ctavan/express-validator/issues"
  },
  "bundleDependencies": false,
  "contributors": [
    {
      "email": "rustylbailey@gmail.com",
      "name": "Rusty Bailey"
    },
    {
      "email": "guhenke@gmail.com",
      "name": "Gustavo Henke"
    }
  ],
  "dependencies": {
    "lodash": "^4.16.0",
    "validator": "^9.4.0"
  },
  "deprecated": false,
  "description": "Express middleware for the validator module.",
  "devDependencies": {
    "@types/express": "^4.11.0",
    "chai": "^4.1.2",
    "coveralls": "^3.0.0",
    "eslint": "^4.5.0",
    "mocha": "^5.0.0",
    "nyc": "^11.1.0",
    "typescript": "^2.3.4"
  },
  "engines": {
    "node": ">= 6.0.0"
  },
  "homepage": "https://github.com/ctavan/express-validator",
  "keywords": [
    "express",
    "validator",
    "validation",
    "validate",
    "sanitize",
    "sanitization",
    "xss"
  ],
  "license": "MIT",
  "main": "./index.js",
  "name": "express-validator",
  "optionalDependencies": {},
  "readme": "# express-validator\r\n\r\n[![npm version](https://img.shields.io/npm/v/express-validator.svg)](https://www.npmjs.com/package/express-validator)\r\n[![Build Status](https://img.shields.io/travis/ctavan/express-validator.svg)](http://travis-ci.org/ctavan/express-validator)\r\n[![Dependency Status](https://img.shields.io/david/ctavan/express-validator.svg)](https://david-dm.org/ctavan/express-validator)\r\n[![Coverage Status](https://img.shields.io/coveralls/ctavan/express-validator.svg)](https://coveralls.io/github/ctavan/express-validator?branch=master)\r\n\r\nAn [express.js]( https://github.com/visionmedia/express ) middleware for\r\n[validator]( https://github.com/chriso/validator.js ).\r\n\r\n- [Upgrade notice](#upgrade-notice)\r\n- [Installation](#installation)\r\n- [Usage](#usage)\r\n- Features\r\n  - [Wildcards (`*`)](#wildcards-)\r\n  - [Dynamic messages](#dynamic-messages)\r\n  - [Schema validation](#schema-validation)\r\n  - [Whole body validation](#whole-body-validation)\r\n- API\r\n  - [`check` API](#check-api)\r\n  - [`filter` API](#filter-api)\r\n  - [Sanitization Chain API](#sanitization-chain-api)\r\n  - [Validation Chain API](#validation-chain-api)\r\n  - [Validation Result API](#validation-result-api)\r\n  - [Legacy API](#legacy-api)\r\n- [Changelog](#changelog)\r\n- [License](#license)\r\n\r\n## Upgrade notice\r\nIf you're arriving here as a express-validator v3 user after upgrading to v4+, please check the [upgrade guide](UPGRADE_GUIDE.md) in order to find out what's different!\r\n\r\n**Also please note that, starting with v5.0.0, no new features will be accepted into the legacy API. Only bug fixes will be made.**\r\n\r\n## Installation\r\n```\r\nnpm install express-validator\r\n```\r\n\r\nAlso make sure that you have Node.js 6 or newer in order to use it.\r\n\r\n## Usage\r\n> The version 3 style of doing validations is still available.  \r\n> Please check the [legacy API](#legacy-api) for the docs.\r\n\r\n```javascript\r\nconst { check, validationResult } = require('express-validator/check');\r\nconst { matchedData, sanitize } = require('express-validator/filter');\r\n\r\napp.post('/user', [\r\n  check('username')\r\n    // Every validator method in the validator lib is available as a\r\n    // method in the check() APIs.\r\n    // You can customize per validator messages with .withMessage()\r\n    .isEmail().withMessage('must be an email')\r\n\r\n    // Every sanitizer method in the validator lib is available as well!\r\n    .trim()\r\n    .normalizeEmail()\r\n\r\n    // ...or throw your own errors using validators created with .custom()\r\n    .custom(value => {\r\n      return findUserByEmail(value).then(user => {\r\n        throw new Error('this email is already in use');\r\n      })\r\n    }),\r\n\r\n  // General error messages can be given as a 2nd argument in the check APIs\r\n  check('password', 'passwords must be at least 5 chars long and contain one number')\r\n    .isLength({ min: 5 })\r\n    .matches(/\\d/),\r\n\r\n  // No special validation required? Just check if data exists:\r\n  check('addresses.*.street').exists(),\r\n\r\n  // Wildcards * are accepted!\r\n  check('addresses.*.postalCode').isPostalCode(),\r\n\r\n  // Sanitize the number of each address, making it arrive as an integer\r\n  sanitize('addresses.*.number').toInt()\r\n], (req, res, next) => {\r\n  // Get the validation result whenever you want; see the Validation Result API for all options!\r\n  const errors = validationResult(req);\r\n  if (!errors.isEmpty()) {\r\n    return res.status(422).json({ errors: errors.mapped() });\r\n  }\r\n\r\n  // matchedData returns only the subset of data validated by the middleware\r\n  const user = matchedData(req);\r\n  createUser(user).then(user => res.json(user));\r\n});\r\n```\r\n\r\n---\r\n\r\n## Wildcards (`*`)\r\n\r\nTo validate or sanitize nested object properties or an array of strings use wildcards (`*`).\r\n\r\n```js\r\n// Validate the postal code of each address, making sure the value is in postal code format \r\ncheck('addresses.*.postalCode').isPostalCode(),\r\n\r\n// Sanitize the number of each address, making it arrive as an integer\r\nsanitize('addresses.*.number').toInt()\r\n```\r\n\r\n---\r\n\r\n## Dynamic messages\r\nYou can build dynamic validation messages by providing functions anywhere a validation message is supported.  \r\nThis is specially useful if you use a translation library to provide tailored messages:\r\n\r\n```js\r\n// check(field, withMessage) and .withMessage() work the same\r\ncheck('something').isInt().withMessage((value, { req, location, path }) => {\r\n  return req.translate('validation.message.path', { value, location, path });\r\n}),\r\ncheck('somethingElse', (value, { req, location, path }) => {\r\n  return req.translate('validation.message.path', { value, location, path });\r\n}),\r\n\r\n// oneOf is special though - it only receives the req object for now\r\noneOf([ someValidation, anotherValidation ], ({ req }) => {\r\n  return req.translate('validation.multiple_failures');\r\n});\r\n```\r\n\r\n---\r\n\r\n## Schema Validation\r\nSchemas are a special, object-based way of defining validations or sanitizations on requests.  \r\nAt the root-level, you specify the field paths as the keys, and an object as values -- which define\r\nthe error messages, locations and validations/sanitizations.\r\n\r\nIts syntaxs looks like this:\r\n\r\n```js\r\nconst { checkSchema } = require('express-validator/check');\r\napp.put('/user/:id/password', checkSchema({\r\n  id: {\r\n    // The location of the field, can be one or more of body, cookies, headers, params or query.\r\n    // If omitted, all request locations will be checked\r\n    in: ['params', 'query'],\r\n    errorMessage: 'ID is wrong',\r\n    isInt: true,\r\n    // Sanitizers can go here as well\r\n    toInt: true\r\n  },\r\n  myCustomField: {\r\n    // Custom validators\r\n    custom: {\r\n      options: (value, { req, location, path }) => {\r\n        return value + req.body.foo + location + path;\r\n      }\r\n    },\r\n    // and sanitizers\r\n    customSanitizer: {\r\n      options: (value, { req, location, path }) => {\r\n        let sanitizedValue;\r\n\r\n        if (req.body.foo && location && path) {\r\n          sanitizedValue = parseInt(value);\r\n        } else {\r\n          sanitizedValue = 0;\r\n        }\r\n\r\n        return sanitizedValue;\r\n      }\r\n    },\r\n  },\r\n  password: {\r\n    isLength: {\r\n      errorMessage: 'Password should be at least 7 chars long',\r\n      // Multiple options would be expressed as an array\r\n      options: { min: 7 }\r\n    }\r\n  },\r\n  firstName: {\r\n    isUpperCase: {\r\n      // To negate a validator\r\n      negated: true,\r\n    },\r\n    rtrim: {\r\n      // Options as an array\r\n      options: [[\" \", \"-\"]],\r\n    },\r\n  },\r\n  // Wildcards/dots for nested fields work as well\r\n  'addresses.*.postalCode': {\r\n    optional: true,\r\n    isPostalCode: true\r\n  }\r\n}), (req, res, next) => {\r\n  // handle the request as usual\r\n})\r\n```\r\n\r\n---\r\n\r\n## Whole Body Validation\r\nSometimes you need to validate requests whose body is a string, an array, or even a number!\r\nThat's why you can omit the field to validate and check `req.body` directly:\r\n\r\n```js\r\nconst { body } = require('express-validator/check');\r\napp.post('/recover-password', body().isEmail(), (req, res) => {\r\n  // Assume the validity was already checked\r\n  User.recoverPassword(req.body).then(() => {\r\n    res.send('Password recovered!');\r\n  });\r\n});\r\n```\r\n\r\n---\r\n\r\n## `check` API\r\nThese methods are all available via `require('express-validator/check')`.\r\n\r\n### `check([field, message])`\r\n- `field` *(optional)*: a string or an array of strings of field names to validate against.\r\n- `message` *(optional)*: an error message to use when failed validators don't specify a message. Defaults to `Invalid value`; see also [Dynamic Messages](#dynamic-messages).\r\n> *Returns:* a [Validation Chain](#validation-chain-api)\r\n\r\nCreates a validation chain for one or more fields. They may be located in any of the following request objects:\r\n- `req.body`\r\n- `req.cookies`\r\n- `req.headers`\r\n- `req.params`\r\n- `req.query`\r\n\r\nIf any of the fields are present in more than one location, then all instances of that field value must pass the validation.\r\n\r\n**Note:** If `fields` is omitted, then the whole request location will be validated.\r\nThis is only useful for `req.body`, though; see [Whole Body Validation](#whole-body-validation) for examples.\r\n\r\nThe validators will always be executed serially for the same field.  \r\nThis means that if the chain targets more than one field, those will run in parallel, but each of their validators are serial.\r\n\r\n### `body([fields, message])`\r\nSame as `check([fields, message])`, but only checking `req.body`.\r\n\r\n### `cookie([fields, message])`\r\nSame as `check([fields, message])`, but only checking `req.cookies`.\r\n\r\n### `header([fields, message])`\r\nSame as `check([fields, message])`, but only checking `req.headers`.\r\n\r\n### `param([fields, message])`\r\nSame as `check([fields, message])`, but only checking `req.params`.\r\n\r\n### `query([fields, message])`\r\nSame as `check([fields, message])`, but only checking `req.query`.\r\n\r\n### `checkSchema(schema)`\r\n- `schema`: the schema to validate. Must comply with the format described in [Schema Validation](#schema-validation).\r\n> *Returns:* an array of validation chains\r\n\r\n### `oneOf(validationChains[, message])`\r\n- `validationChains`: an array of [validation chains](#validation-chain-api) created with `check()` or any of its variations,\r\n  or an array of arrays containing validation chains.\r\n- `message` *(optional)*: an error message to use when all chains failed. Defaults to `Invalid value(s)`; see also [Dynamic Messages](#dynamic-messages).\r\n> *Returns:* a middleware instance\r\n\r\nCreates a middleware instance that will ensure at least one of the given chains passes the validation.  \r\nIf none of the given chains passes, an error will be pushed to the `_error` pseudo-field,\r\nusing the given `message`, and the errors of each chain will be made available under a key `nestedErrors`.\r\n\r\nExample:\r\n\r\n```js\r\nconst { check, oneOf, validationResult } = require('express-validator/check');\r\napp.post('/start-freelancing', oneOf([\r\n  check('programming_language').isIn(['javascript', 'java', 'php']),\r\n  check('design_tools').isIn(['photoshop', 'gimp'])\r\n]), (req, res, next) => {\r\n  try {\r\n    validationResult(req).throw();\r\n\r\n    // yay! we're good to start selling our skilled services :)))\r\n    res.json(...);\r\n  } catch (err) {\r\n    // Oh noes. This user doesn't have enough skills for this...\r\n    res.status(422).json(...);\r\n  }\r\n});\r\n```\r\n\r\nIf an item of the array is an array containing validation chains, then all of those must pass in order for this\r\ngroup be considered valid:\r\n\r\n```js\r\n// This protected route must be accessed either by passing both username + password,\r\n// or by passing an access token\r\napp.post('/protected/route', oneOf([\r\n  [\r\n    check('username').exists(),\r\n    check('password').exists()\r\n  ],\r\n  check('access_token').exists()\r\n]), someRouteHandler);\r\n```\r\n\r\nThe execution of those validation chains are made in parallel,\r\nwhile the execution within a chain still respects the rule defined in the [`check()` function](#checkfield-message).\r\n\r\n### `validationResult(req)`\r\n- `req`: the express request object.\r\n> *Returns:* a [validation result](#validation-result-api) object\r\n\r\nExtracts the validation errors from a request and makes it available in the form of a validation result object.\r\n\r\n### `buildCheckFunction(locations)`\r\n- `locations`: an array of request locations to gather data from.  \r\n   May include any of `body`, `cookies`, `headers`, `params` or `query`.\r\n> *Returns:* a variant of [`check()`](#checkfield-message) checking the given request locations.\r\n\r\nCreates a variant of [`check()`](#checkfield-message) that checks the given request locations.\r\n\r\n```js\r\nconst { buildCheckFunction } = require('express-validator/check');\r\nconst checkBodyAndQuery = buildCheckFunction(['body', 'query']);\r\n\r\napp.put('/update-product', [\r\n  // id must be either in req.body or req.query, and must be an UUID\r\n  checkBodyAndQuery('id').isUUID()\r\n], productUpdateHandler)\r\n```\r\n\r\n---\r\n\r\n## `filter` API\r\nThese methods are all available via `require('express-validator/filter')`.\r\n\r\n### `matchedData(req[, options])`\r\n- `req`: the express request object.\r\n- `options` *(optional)*: an object which accepts the following options:\r\n  - `onlyValidData`: if set to `false`, the returned value includes data from fields\r\n    that didn't pass their validations. Defaults to `true`.\r\n  - `locations`: an array of locations to extract the data from. The acceptable values include\r\n    `body`, `cookies`, `headers`, `params` and `query`. Defaults to `undefined`, which means all locations.\r\n> *Returns:* an object of data validated by the `check` APIs.\r\n\r\nExtracts data validated by the `check` APIs from the request and builds\r\nan object with them. Nested paths and wildcards are properly handled as well.\r\n\r\n```js\r\n// Suppose the request looks like this:\r\n// req.query = { from: '2017-01-12' }\r\n// req.body = { to: '2017-31-12' }\r\n\r\napp.post('/room-availability', check(['from', 'to']).isISO8601(), (req, res, next) => {\r\n  const queryData = matchedData(req, { locations: ['query'] });\r\n  const bodyData = matchedData(req, { locations: ['body'] });\r\n  const allData = matchedData(req);\r\n  console.log(queryData); // { from: '2017-01-12' }\r\n  console.log(bodyData);  // { to: '2017-31-12' }\r\n  console.log(allData);   // { from: '2017-01-12', to: '2017-31-12' }\r\n});\r\n```\r\n\r\n### `sanitize(fields)`\r\n- `field`: a string or an array of strings of field names to validate against.\r\n> *Returns:* a [Sanitization Chain](#sanitization-chain-api)\r\n\r\nCreates a sanitization chain for one or more fields. They may be located in any of the following request objects:\r\n- `req.body`\r\n- `req.cookies`\r\n- `req.params`\r\n- `req.query`\r\n\r\n_* `req.headers` is **not** supported at the moment._\r\n\r\nIf any of the fields are present in more than one location, then all instances of that field value will be sanitized.\r\n\r\n### `sanitizeBody(fields)`\r\nSame as `sanitize(fields)`, but only sanitizing `req.body`.\r\n\r\n### `sanitizeCookie(fields)`\r\nSame as `sanitize(fields)`, but only sanitizing `req.cookies`.\r\n\r\n### `sanitizeParam(fields)`\r\nSame as `sanitize(fields)`, but only sanitizing `req.params`.\r\n\r\n### `sanitizeQuery(fields)`\r\nSame as `sanitize(fields)`, but only sanitizing `req.query`.\r\n\r\n### `buildSanitizeFunction(locations)`\r\n- `locations`: an array of request locations to gather data from.  \r\n   May include any of `body`, `cookies`, `params` or `query`.\r\n> *Returns:* a variant of [`sanitize()`](#sanitizefields) sanitizing the given request locations.\r\n\r\nCreates a variant of [`sanitize()`](#sanitizefields) that sanitizes the given request locations.\r\n\r\n```js\r\nconst { buildSanitizeFunction } = require('express-validator/filter');\r\nconst sanitizeBodyAndQuery = buildSanitizeFunction(['body', 'query']);\r\n\r\napp.put('/update-product', [\r\n  // id being either in req.body or req.query will be converted to int\r\n  sanitizeBodyAndQuery('id').toInt()\r\n], productUpdateHandler)\r\n```\r\n\r\n---\r\n\r\n## Sanitization Chain API\r\nThe sanitization chain is a middleware, and it should be passed to an Express route handler.  \r\nWhen the middleware runs, it will modify each field in place, applying each of the sanitizers in the order they were specified:\r\n\r\n```js\r\napp.get('/', sanitizeBody('trimMe').trim(), (req, res, next) => {\r\n  // If req.body.trimMe was originally \"  something \",\r\n  // its sanitized value will be \"something\"\r\n  console.log(req.body.trimMe);\r\n});\r\n```\r\n\r\nAny of the sanitization methods listed by [validator.js](https://github.com/chriso/validator.js) are made available in all sanitization chains created by express-validator, as long as we're supporting the most up-to-date validator version.\r\n\r\nAdditionally, the following methods are also available:\r\n\r\n### `.customSanitizer(sanitizer)`\r\n- `sanitizer(value, { req, location, path })`: the custom sanitizer function.  \r\n  Receives the value of the field being sanitized, as well as the express request, the location and the field path.\r\n> *Returns:* the current sanitization chain instance\r\n\r\nAdds a custom sanitizer to the current sanitization chain. It must synchronously return the new value.\r\n\r\nExample:\r\n\r\n```js\r\napp.get('/object/:id', sanitizeParam('id').customSanitizer((value, { req }) => {\r\n  return req.query.type === 'user' ? ObjectId(value) : Number(value);\r\n}), objectHandler)\r\n```\r\n\r\n---\r\n\r\n## Validation Chain API\r\nAny of the validation and sanitization methods listed by [validator.js](https://github.com/chriso/validator.js) are made available in all validation chains created by express-validator, as long as we're supporting the most up-to-date validator version.  \r\nIf you use any of the sanitizers together with validators, the validated value is the sanitized one.\r\n\r\n**Note:** Chains are mutable. Every time you call one of its methods, you're adding more behavior to the same chain.  \r\nKeep this in mind and note that you probably want to use a factory function when reusing some chain base.\r\n\r\nAdditionally, the following methods are also available:\r\n\r\n### `.custom(validator)`\r\n- `validator(value, { req, location, path })`: the custom validator function.  \r\nReceives the value of the field being validated, as well as the express request, the location and the field path.\r\n> *Returns:* the current validation chain instance\r\n\r\nAdds a custom validator to the current validation chain.  \r\nThe custom validator may return a promise to indicate an async validation task. In case it's rejected, the field is considered invalid.\r\n\r\nThe custom validator may also throw JavaScript exceptions (eg `throw new Error()`) and return falsy values to indicate the field is invalid.\r\n\r\nExample:\r\n\r\n```js\r\napp.post('/create-user', [\r\n  check('password').exists(),\r\n  check('passwordConfirmation', 'passwordConfirmation field must have the same value as the password field')\r\n    .exists()\r\n    .custom((value, { req }) => value === req.body.password)\r\n], loginHandler);\r\n```\r\n\r\n### `.customSanitizer(sanitizer)`\r\nSame as [`.customSanitizer` from the Sanitization Chain](#customsanitizersanitizer).\r\n\r\n### `.exists()`\r\n> *Returns:* the current validation chain instance\r\n\r\nAdds a validator to check for the existence of the current fields in the request.  \r\nThis means the value of the fields may not be `undefined`; any other values are acceptable.\r\n\r\n### `.isArray()`\r\n> *Returns:* the current validation chain instance\r\n\r\nAdds a validator to check if a value is an array.\r\n\r\n### `.isString()`\r\n> *Returns:* the current validation chain instance\r\n\r\nAdds a validator to check if a value is a string.\r\n\r\n### `.not()`\r\n> *Returns:* the current validation chain instance\r\n\r\nNegates the result of the next validator.\r\n\r\n```js\r\ncheck('weekday').not().isIn(['sunday', 'saturday'])\r\n```\r\n\r\n### `.optional(options)`\r\n- `options` *(optional)*: an object of options to customize the optionality behaviour. Please check it below.\r\n> *Returns:* the current validation chain instance\r\n\r\nMarks the current validation chain as optional.  \r\nThis is useful to remove values that are not essential to your busines and that would cause validation failures in case they were not provided in the request.\r\n\r\nBy default, fields with `undefined` values will be ignored from the validation.\r\n\r\nYou can further customize this behavior by passing an object with the following options:\r\n- `nullable`: if `true`, fields with `null` values will be considered optional\r\n- `checkFalsy`: if `true`, fields with falsy values (eg `\"\"`, `0`, `false`, `null`) will also be considered optional\r\n\r\n### `.withMessage(message)`\r\n- `message`: the error message to use for the previous validator\r\n> *Returns:* the current validation chain instance\r\n\r\nSets the error message for the previous validator.  \r\nThis will have precedence over errors thrown by a custom validator.\r\n\r\nTo build dynamic messages, see also [Dynamic Messages](#dynamic-messages).\r\n\r\n---\r\n\r\n## Validation Result API\r\nThis is an unified API for dealing with errors, both in legacy and check APIs.\r\n\r\nEach error returned by `.array()` and `.mapped()` methods have the following format by default:\r\n\r\n```js\r\n{\r\n  \"msg\": \"The error message\",\r\n  \"param\": \"param.name.with.index[0]\",\r\n  \"value\": \"param value\",\r\n  // Location of the param that generated this error.\r\n  // It's either body, query, params, cookies or headers.\r\n  \"location\": \"body\",\r\n\r\n  // nestedErrors only exist when using the oneOf function\r\n  \"nestedErrors\": [{ ... }]\r\n}\r\n```\r\n\r\n### `.isEmpty()`\r\n> *Returns:* a boolean indicating whether this result object contains no errors at all.\r\n\r\n### `.formatWith(formatter)`\r\n- `formatter(error)`: the function to use to format when returning errors.  \r\n  The `error` argument is an object in the format of `{ location, msg, param, value, nestedErrors }`, as described above.\r\n> *Returns:* this validation result instance\r\n\r\n```js\r\napp.post('/create-user', yourValidationChains, (req, res, next) => {\r\n  const errorFormatter = ({ location, msg, param, value, nestedErrors }) => {\r\n    // Build your resulting errors however you want! String, object, whatever - it works!\r\n    return `${location}[${param}]: ${msg}`;\r\n  };\r\n  const result = validationResult(req).formatWith(errorFormatter);\r\n  if (!result.isEmpty()) {\r\n    // Response will contain something like\r\n    // { errors: [ \"body[password]: must be at least 10 chars long\" ] }\r\n    return res.json({ errors: result.array() });\r\n  }\r\n\r\n  // Handle your request as if no errors happened\r\n});\r\n```\r\n\r\n### `.array([options])`\r\n- `options` *(optional)*: an object of options. Defaults to `{ onlyFirstError: false }`\r\n> *Returns:* an array of validation errors.\r\n\r\nGets all validation errors contained in this result object.\r\n\r\nIf the option `onlyFirstError` is set to `true`, then only the first\r\nerror for each field will be included.\r\n\r\n### `.mapped()`\r\n> *Returns:* an object where the keys are the field names, and the values are the validation errors\r\n\r\nGets the first validation error of each failed field in the form of an object.\r\n\r\n### `.throw()`\r\nIf this result object has errors, then this method will throw an exception\r\ndecorated with the same validation result API.\r\n\r\n```js\r\ntry {\r\n  validationResult(req).throw();\r\n  // Oh look at ma' success! All validations passed!\r\n} catch (err) {\r\n  console.log(err.mapped()); // Oh noes!\r\n}\r\n```\r\n\r\n### `.withDefaults(options)`\r\n- `options` *(optional)*: an object of options. Defaults to `{ formatter: error => error }`\r\n> *Returns:* a new [validationResult](#validationresultreq) function is returned, using the provided options\r\n\r\nThis is useful when you have a consistent set of options you would like to use for all validation results throughout your application.\r\n\r\nBelow is an example which sets a default error formatter:\r\n\r\n```\r\nconst { validationResult } = require('express-validator/check');\r\n\r\nconst result = validationResult.withDefaults({\r\n    formatter: (error) => {\r\n        return {\r\n            myLocation: error.location,\r\n        };\r\n    }\r\n});\r\n\r\nmodule.exports = result;\r\n```\r\n---\r\n\r\n## Legacy API\r\nThe \"legacy API\" is the same API used by version 3 and older releases of express-validator.\r\n\r\nIt's based around setting a global middleware in your express app and decorating the request object with new methods.\r\n\r\n> This API **MUST NOT** be used by new apps, since it may not receive new updates and can even be removed in a future major version.\r\n\r\n### Setup\r\nYou must mount the middleware in your app before you get access to the validation/sanitization methods:\r\n\r\n```js\r\nconst expressValidator = require('express-validator');\r\napp.use(expressValidator(middlewareOptions));\r\n```\r\n\r\n### Middleware options\r\n- `errorFormatter (param, msg, value, location)`: a function that formats the error objects before returning them to your route handlers.\r\n- `customValidators`: an object where you can specify custom validators.  \r\nThe key will be the name of the validator, while the value is the validation function, receiving the value and any option.\r\n- `customSanitizers`: an object where you can specify custom sanitizers.  \r\nThe key will be the name of the sanitizer, while the value is the sanitization function, receiving the value and any option.\r\n\r\n### Legacy Validation Chain\r\nThe Legacy Validation Chain instances provides further functionality than the one provided by the base [Validation Chain](#validation-chain-api) objects.  \r\nIt also differs in that the legacy one is not a middleware *per se*.\r\n\r\nAny custom validator specified in the middleware will be made available \r\nin instances of this validation chain.\r\n\r\nAdditionally, the following validators are also available:\r\n\r\n- `.notEmpty()`: alias of `.isLength({ min: 1 })`\r\n- `.len()`: alias of `.isLength()`\r\n\r\n### `req.check(field[, message])`\r\n- `field`: the name of a single field to validate against.\r\n- `message` *(optional)*: an error message to use when failed validators don't specify a message. Defaults to `Invalid value`.\r\n> *Returns:* a [legacy validation chain](#legacy-validation-chain)\r\n\r\nCreates a validation chain for one field. It may be located in any of the following request objects:\r\n- `req.params`\r\n- `req.query`\r\n- `req.body`\r\n- `req.headers`\r\n- `req.cookies`\r\n\r\nIf it's present in more than one location, then only the first one (following the above order) will be validated against.\r\n\r\n> This function is also aliased as `req.assert()` and `req.validate()`.\r\n\r\n### `req.checkBody(field[, message])`\r\nSame as `req.check(field[, message])`, but only checking `req.body`.\r\n\r\n### `req.checkCookies(field[, message])`\r\nSame as `req.check(field[, message])`, but only checking `req.cookies`.\r\n\r\n### `req.checkHeaders(field[, message])`\r\nSame as `req.check(field[, message])`, but only checking `req.headers`.\r\n\r\n### `req.checkParams(field[, message])`\r\nSame as `req.check(field[, message])`, but only checking `req.params`.\r\n\r\n### `req.checkQuery(field[, message])`\r\nSame as `req.check(field[, message])`, but only checking `req.query`.\r\n\r\n### `req.sanitize(field)`\r\n> *Returns:* a sanitizer chain\r\n\r\nCreates a sanitizer chain that, when any of the sanitization methods is used, the return value is the sanitized value.  \r\nAlso, the parameter is sanitized in-place; that is, in the below example,\r\n`req.body.comment` will be updated to the sanitized value.\r\n\r\n```js\r\nconst comment = req.sanitize('comment').trim();\r\nconsole.log(comment === req.body.comment);\r\n```\r\n\r\nIf the sanitized parameter is present in more than one location (eg `req.query.comment` and `req.body.comment`), the will all be sanitized.\r\n\r\n> This function is also aliased as `req.filter()`.\r\n\r\n### `req.sanitizeBody(field[, message])`\r\nSame as `req.sanitize(field[, message])`, but only sanitizing `req.body`.\r\n\r\n### `req.sanitizeCookies(field[, message])`\r\nSame as `req.sanitize(field[, message])`, but only sanitizing `req.cookies`.\r\n\r\n### `req.sanitizeHeaders(field[, message])`\r\nSame as `req.sanitize(field[, message])`, but only sanitizing `req.headers`.\r\n\r\n### `req.sanitizeParams(field[, message])`\r\nSame as `req.sanitize(field[, message])`, but only sanitizing `req.params`.\r\n\r\n### `req.sanitizeQuery(field[, message])`\r\nSame as `req.sanitize(field[, message])`, but only sanitizing `req.query`.\r\n\r\n### `req.getValidationResult()`\r\n> *Returns:* a promise for a [Validation Result](#validation-result-api) object\r\n\r\nRuns all validations and returns a validation result object for the errors gathered, for both sync and async validators.\r\n\r\n### `req.asyncValidationErrors([mapped])`\r\n- `mapped` *(optional)*: whether the result must be an object instead of an array. Defaults to `false`.\r\n> *Returns:* a promise which will resolve in case all validators passed, or reject with an array of errors or an object of errors (in case `mapped` argument is `true`).\r\n\r\nRuns all validations and returns the errors gathered for all of them.\r\n\r\n### `req.validationErrors([mapped])`\r\n- `mapped` *(optional)*: whether the result must be an object instead of an array. Defaults to `false`.\r\n> *Returns:* `false` if no errors happened, an array of errors or an object of errors (in case `mapped` argument is `true`).\r\n\r\nRuns all validations and returns the errors gathered *only* for the completed validators.  \r\nThis probably means any async validator will not be completed by the time this method responds.\r\n\r\n### Schema validation\r\nAll `req.check` methods can do schema validation. The schema syntax is the same as described in [Schema Validation](#schema-validation).\r\n\r\n---\r\n\r\n## Changelog\r\n\r\nCheck the [GitHub Releases page](https://github.com/ctavan/express-validator/releases).\r\n\r\n## License\r\n\r\nMIT License\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/ctavan/express-validator.git"
  },
  "scripts": {
    "lint": "eslint lib test check filter",
    "report-coverage": "cat coverage/lcov.info | coveralls",
    "test": "nyc mocha && tsc",
    "travis-build": "npm test && npm run lint"
  },
  "types": "./index.d.ts",
  "version": "5.1.2"
}
